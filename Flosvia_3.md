keyword.kwlist



# 변수

- 변수 선언 a = 1

  - a.real : 실수 부분은 나타낸다.

  - a.imag : 허수 부분을 나타낸다.

  - a.conjugate : 켤레복소수를 나타낸다.

- id(변수명) : 변수에 내장된 값이 저장된 메모리의 주소를 반환한다.
  - a = [ 1, 2, 3 ]
  - b = a
    - 위와 같이 표기하면 b는 a의 값이 저장된 메모리의 주소를 가리키기 때문에 a의 값을 변경하면 b의 값도 바뀌게 된다.
    - 이를 방지하는 방법 중 2가지
      - 값 전체를 복사하여 저장한다.
        - b = a[:]
      - copy 모듈을 이용한다.
        - from copy import copy
        - b = copy(a)
    - 제대로 처리되었다면 b is a를 실행해서 False가 반환된다.



- 대소문자를 구분한다.
- 문자와 _로 시작할 수 있으나 숫자로 시작할 수 없고 특수 문자와 키워드는 쓸 수 없다.



- 할당 연산자 '='
  - 변수에 내장된 값을 바꾼다.

- 부호 붙이기
  - 변수 앞에 부호를 붙이면 그대로 계산된다.

- 입력받은 값 저장하기
  - 변수 = input() : 입력값이 변수에 저장된다.
  - 두 개씩 저장하기
    - 변수1, 변수2 = input().split()
      - split의 괄호 안에 작은따옴표를 붙이고 안에 다른 문자를 넣으면 그걸 기준으로 분리한다.
      - 입력받은 값을 모두 변환하기
        - 변수1, 변수2 = map(자료형, input().split())

# 변환 함수

- int(321) : 실수를 정수로 변환, int('321') : 문자열을 정수로 변환

- 자료형 int : 정수. float : 실수, complex : 복소수, str : 문자열

- int는 문자열이 정수일 때만 int로 변환이 가능하다.

- float는 정수와 실수를 모두 float로 변환이 가능하다.



# 함수

- 출력 : print(a)
  - 괄호 안의 값을 쉼표로 구분해 넣으면 공백으로 띄워져 한 줄로 출력된다.
    - 공백 대신 다른 문자를 넣고 싶다면 마지막에 sep = '대신 넣을 문자'를 입력하면 된다.

- 자료형 확인 : type(a)



문자열에 덧셈과 곱셈이 가능하다.

덧셈의 경우 문자열이 연결되고, 곱셈의 경우 문자열이 곱한 수만큼 반복된다.



'/' 연산자는 나누고, '//' 연산자는 몫을 구하며, '%' 연산자는 나머지를 구한다.



# 인덱스

- 인덱스(순서에 따라 매겨진 번호)는 기본적으로 0으로 시작하지만 음수로 표현할 수도 있다.

- 음수로 표현할 경우 마지막부터 -1에서 시작하며 첫 번쨰는 '-글자수'를 갖는다.



# 슬라이싱

- 문자열에서 원하는 부분을 잘라 가져오는 것을 뜻한다.

- 문자열[인덱스 1 : 인덱스 2( : 숫자)]

  - 인덱스 1부터 인덱스 2 바로 앞까지의 문자열을 가져온다.

  - 겹치는 구간이 없다면 빈 인덱스를 반환한다.

  - 인덱스 1을 생략 시 맨 앞부터 가져온다.

  - 인덱스 2를 생략 시 맨 끝까지 가져온다.

  - 둘 모두 생략 시 전체를 가져온다.

  - 숫자에 2를 입력 시 문자열을 가져올 때 한 칸씩 건너뛴다.

    - 예시 : a = "Pythongood", a[1:7:2] = yhn



# 리스트

- 리스트명 = [요소1, 요소2, 요소3, ...] - 문자열, 요소, 리스트를 혼용할 수 있다.
  - 리스트.append("리스트에 넣을 요소") : 리스트의 맨 마지막에 삽입된다.
  - 리스트.remove("리스트에서 지울 요소") : 리스트에서 적은 요소를 삭제한다.
  - 리스트.insert(넣을 위치, 넣을 요소) : 리스트에서 정한 위치에 적은 요소를 삽입한다.
  - 리스트.sort() : 리스트의 요소들을 차례대로 정렬한다.(서로 다른 자료형이 섞인 경우{예 : 숫자와 알파벳이 섞인 경우}에는 정렬이 되지 않는다.)
  - 리스트.reverse() : 리스트의 순서를 거꾸로 뒤집는다.
  - 리스트.pop(인덱스 번호) : 리스트에서 그 인덱스 번호를 가진 요소(생략할 경우 마지막 요소)를 반환하고 삭제한다.
  - 리스트.count(요소) : 리스트에 그 요소가 몇 개 포함되어 있는지 확인하여 반환한다.
- 리스트.extend(다른 리스트) : 다른 리스트의 요소들을 리스트 뒤에 병합한다.
- 리스트명[인덱스 번호]로 개별 요소를 호출할 수 있다.
  - 예시 : a[1, 2, 3]
    		   a[0] + a[2] = 1 + 3 = 4
  - a[2] = 4 같이 개별 요소에 값을 대입할 수도 있다.
  - del a[인덱스 번호]을 실행하면 a에서 그 인덱스 번호를 가진 요소가 삭제된다.(슬라이싱으로 일정 영역에 있는 요소를 한꺼번에 삭제하는 것도 가능하다.)
  - 리스트명[인덱스 번호] [인덱스 번호]로 리스트 안의 리스트의 요소를 호출한다.
- 리스트 = 문자열.split()
  - split 뒤의 괄호 안의 문자를 기준으로 문자열을 쪼개 리스트화한다.
- " ".join(리스트)
  - 리스트를 큰따옴표 안의 문자를 기준으로 이어 문자열화한다.

# 튜플

리스트와 거의 동일하나 다른 점은 다음과 같다.

- 리스트가 [ ]로 요소들을 둘러싸는 것과는 달리 튜플은 ( )를 쓴다.
- 리스트는 요소에 다른 값을 대입하는 등 값의 생성, 삭제, 수정이 가능하지만 튜플은 불가능하다.
- 튜플은 ( )를 생략하더라도 문제가 없다.
- 튜플은 요소가 1개이더라도 뒤에 반점을 찍어야 한다. 예시 : t1 = (1,)



# 딕셔너리

딕셔너리는 Key 값에 Value 값이 대응되는 자료형을 칭한다.

예시 :  dic = { 'name' : 'Im Jae Yeong', 'phone' : '01086813972', 'birth' : '20050829' }

Key 값에는 리스트는 들어갈 수 없고 튜플은 쓸 수 있으나 Value 값에는 리스트도 들어갈 수 있다.

Key 값은 딕셔너리에서 고유한 값이므로 중복될 경우 하나를 제외한 나머지 값이 깡그리 무시된다.



- 쌍 추가하기
  - a[Key 값] = Value 값을 입력하면 그 Key 값을 가진 { Key : Value } 쌍이 생성된다.
  - 예시
    - a = {1: 'a'}
    - a[2] = 'b'
    - a {1: 'a', 2: 'b'}
- 요소 삭제하기
  - del a[Key 값]을 입력하면 그 Key 값을 가진 { Key : Value } 쌍이 삭제된다.
- 개별 요소 호출하기
  - 딕셔너리는 슬라이싱과 같은 기능이 없어 무조건 Key 값을 이용해 Value 값을 호출해야 한다.
  - 딕셔너리명[Key 값]을 이용하면 Value 값을 호출할 수 있다.(존재하지 않는 Key 값으로 호출하려 할 경우 오류를 발생시킨다.)
    - 딕셔너리명.get(Key 값)도 동일하나 존재하지 않는 Key 값으로 호출하려 할 경우 오류를 발생시키는 대신 None을 반환하며, 미리 정해둔 기본 값을 반환받고 싶을 때는 딕셔너리명.get(Key 값, '기본 값')을 사용하면 된다.
- Key 값 목록 만들기
  - 딕셔너리명.keys() -> 딕셔너리의 Key 값만을 모아서 dict_keys([Key 값])의 형태로 돌려준다.
  - dict_keys가 아니라 리스트로 Key 값 목록을 반환받고 싶다면 list(a.keys())를 사용하면 된다.
- Value 값 목록 만들기
  - dict_keys 대신 dict_values를 반환하는 걸 제외하면 Key 값 목록을 만드는 것과 완전히 동일하다.
  - 딕셔너리명.values()
- Key, Value 쌍 얻기
  - 딕셔너리명.items()
  - Key 값과 Value 값을 쌍으로 삼아 튜플로 묶은 값을 dict_items 객체로 반환한다.
  - dict_keys, dict_values, dict_items는 기본적으로 리스트와 동일하나 append, insert, pop, remove, sort 함수는 작동하지 않는다.
- Key, Value 쌍 모두 지우기
  - 딕셔너리명.clear()
  - 딕셔너리 안의 모든 요소를 삭제하고, 빈 딕셔너리는 { }로 표기된다.
- 특정 Key 값이 딕셔너리 안에 있는지 조사하기
  - Key 값 in 딕셔너리명
    - 있을 경우 True, 없을 경우 False를 반환한다.



# 집합

집합에 관련된 것을 쉽게 처리할 수 있는 자료형을 뜻한다.

예시 : s1 = set(1, 2, 3)

리스트와 튜플도 집합의 요소가 될 수 있다.

- 집합이 갖는 특징
  - 중복을 허용하지 않는다.
  - 정해진 순서가 없다.

집합에 저장된 값을 인덱스 번호를 통해 접근하려면 리스트나 튜플로 변환하는 과정을 거쳐야 한다.



- 교집합
  - 집합1 & 집합2
  - 집합1.intersection(집합2)
- 합집합
  - 집합1 | 집합2
  - 집합1.union(집합2)
- 차집합
  - 집합1  - 집합2
  - 집합1.difference(집합2)



- 값 추가하기
  - 값 1개 추가하기
    - 집합명.add(넣을 요소)
  - 값 여러 개 추가하기
    - 집합명.update(넣을 요소들)
  - 특정 값 제거하기
    - 집합명.remove(제거할 요소)



# 불

참과 거짓을 나타내는 자료형



특징

- True와 False의 2가지 값만 가질 수 있다.
- 문자열, 리스트, 튜플, 딕셔너리 등의 값이 비어 있으면 거짓으로 취급한다.



# 문자열 명령어

- len(문자열)

  - 문자열의 길이를 반환한다.

- 문자열.count("인자")

  - 문자열에서 인자의 개수를 세어 반환한다.

- 문자열.upper()

  - 모두 대문자로 변환한다.

- 문자열.lower() 

  - 모두 소문자로 변환한다.

- 문자열.strip() 

  - 왼쪽, 오른쪽 모두 공백을 제거한다.

- 문자열.lstrip()과 문자열.rstrip()

  - 각각 왼쪽, 오른쪽의 공백 제거한다.
  - 문자열.strip('삭제할 문자')
    - 양쪽에 있는 해당 문자를 제거한다.
    - 문자열.lstrip()과 문자열.rstrip()도 동일하게 작동한다.

- 문자열.replace("대체될 문자열", "대체할 문자열") 

  - 특정 문자열 대체, 대체될 문자열이 문자열 내에 없더라도 오류를 발생시키지 않는다.

- 문자열.find("찾을 인자")

  - 문자열에서 인자를 왼쪽부터 찾아서 인덱스 번호를 반환한다.

- 문자열.rfind("찾을 인자")

  - 문자열에서 인자를 오른쪽부터 찾아서 인덱스 번호를 반환한다.

- 문자열.find("존재하지 않는 인자")

  - 찾지 못한다면 -1을 반환한다.

- 문자열.maketrans('대체될 문자들', '대체할 문자들') : 문자열이 아닌 문자 단위로 대체한다.

  - table = 문자열.maketrans('aeiou', '12345')

  - 'apple'.translate(table)

    - a = "library"

    - table = a.maketrans('lib', 'g')

    - 길이가 다르면 오류가 나면서 실행이 안된다!

    - 두 문자열 중 하나를 생략해도 길이가 다르다며 실행이 안된다!

    - a.translate(table)

- 문자열.index(''), 문자열.rindex()

  - 각각 왼쪽, 오른쪽부터 특정 문자열을 찾아서 첫 글자의 인덱스 번호를 반환한다.

  - 찾지 못한다면 오류가 발생한다.

- 문자열.ljust(), 문자열.rjust() 

  - 각각 문자열을 왼쪽, 오른쪽으로 정렬하고 남을 경우 공백을 생성한다.

- 문자열.center()

  - 문자열을 가운데 정렬하고 홀수일 경우 왼쪽에 공백 한 칸을 생성한다.

- 문자열.zfill(개수) : 지정된 길이에 맞춰 문자열의 왼쪽에 0을 채운다.

  - '3.5'.zfill(개수) : 0003.5로 바뀐다.

- "문자" in 문자열
  - 문자열에 문자가 있는지 확인한다.

메서드 체이닝 : 여러 메서드를 계속 줄줄이 연결해 호출하는 것을 의미한다.

# 포매팅 연산자

- 서식 지정
  - "%s, %d 등"  % 넣을 문자열 또는 숫자
    - '%s' % '문자열' -> %s 자리에 문자열을 대입한다.
    - '%d' % 숫자 -> %d 자리에 숫자를 정수형으로 대입한다.
    - '%f' % 숫자 -> %f 자리에 숫자를 실수형으로 대입한다.(float는 기본적으로 소수점 이하 6자리까지 표시)
    - 2개 이상일 경우 '%s %d' % (넣을 문자열, 넣을 숫자)와 같은 형식으로 표기한다.
    - 서식 지정과 %를 같이 쓰려면 %%로 표기해야 한다.
    - %문자열 길이s
      - 대입되는 값을 오른쪽으로 정렬하고 그 앞의 나머지는 공백으로 채운다.
    - %-문자열 길이s
      - 왼쪽으로 정렬한다.

- %0.숫자f

  - 대입되는 값의 소수점 숫자를 제한하여 출력한다.

  - 정렬과 소수점은 병행 가능하다.

"문자열에 포함된 {0}, {1}, {2}".format(3(숫자), "five"(문자열), number(변수))

문자열 내의 {0}의 개수가 대입되는 값의 개수보다 적다면 남은 건 그냥 버려진다.

{인덱스}가 생략되어있으면 그냥 순서대로 대입된다.

둘 이상을 대입하려면 "{0}, {1}".format(숫자, 문자열)

이름으로 넣으려면 "{number}, {day}".format(number = 10, day = 3)

둘을 혼용할 수 있다.

- "{0:<문자열 자릿수}".format(넣을 값)
  - 왼쪽으로 정렬하고 문자열의 총 자릿수를 맞춘다.

- "{0:>문자열 자릿수}".format(넣을 값)
  - 오른쪽으로 정렬한다.

- "{0:^문자열 자릿수}".format(넣을 값)
  - 가운데 정렬한다.

- "{0:공백을 대체할 문자^문자열 자릿수}".format(넣을 값)
  - 공백이 모두 넣은 문자로 치환된다.

- "{0:0.소수점 자릿수f}".format(소수)
  - 소수점을 입력한 자릿수까지 잘라서 출력한다.
  - 인덱스 순서대로 할 거면 생략해도 된다.



0 대신 문자열의 자릿수를 입력하면 정렬과 동시에 소수점을 잘라 출력할 수 있다.

포매팅 중 중괄호를 그대로 출력하고 싶을 경우 2개를 연속해서 사용하면 된다.

문자열 앞에 f를 붙이면 문자열 내에 중괄호로 묶인 것을 치환해준다.

- 정수를 표현하는 방법
  - "{:d}".format(정수)
    - 정수를 대입한다.
  - "{:5d}".format(정수)
    - 최소 5칸을 차지하게끔 정수를 대입한다.
  - "{:+d}".format(정수)
    - 양수면 +를 표시한다.
  - "{:=+d}".format(정수)
    - +를 맨 앞에 표시한다.
  - "{:05d}".format(정수)
    - 빈칸은 0으로 채운다.
  - "{:+05d}".format(정수)
    - 양수면 0 앞에 +를 표시한다.
- 실수를 표현하는 방법
  - "{:f}".format(실수)
    - 실수를 대입한다.(기본 소수점 6자리)
  - "{:12f}".format(실수)
    - 최소 12칸을 차지하게끔 실수를 대입한다.
  - "{:12.1f}".format(실수)
    - 소수점 1자리까지 반올림해서 표시한다.



# if 문

들여쓰기는 필수! ( 들여쓴 너비가 달라서도 안되고 공백 4칸과 탭을 혼용해서도 안된다. )

조건문 뒤에 :(콜론)을 다는 것도 필수!



C언어에서의 &&, || 등을 대체하는 or, and, not 연산자가 존재한다.

리스트, 튜플, 문자열 안에 요소가 있는지 확인할 수 있는 in, not in 연산자 또한 존재한다.

아무 동작도 하지 않고 넘어가도록 하고 싶다면 pass를 사용하면 된다.

elif : else에 if를 넣는 대신 elif 하나로 앞의 조건문이 거짓이며 조건이 충족된다면 실행하도록 할 수 있다.

코드가 짧다면 들여쓰기를 하는 대신 :(콜론) 뒤에 바로 적어주어도 된다.



# 레인지

- range(n) -> 0부터 n-1까지 1씩 증가한다.
- range(1, n) -> 1부터 n-1까지 1씩 증가한다.
- range(1, n, 2) -> 1부터 n-1까지 2씩 증가한다.